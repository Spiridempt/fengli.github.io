{"sha":"34977ea92427dc456243640baa23bf2cd62a11f8","commit":{"author":{"name":"Magnus Ernstsson","email":"magnus@ernstsson.net","date":"2016-05-26T17:44:55Z"},"committer":{"name":"Magnus Ernstsson","email":"magnus@ernstsson.net","date":"2016-05-26T17:44:55Z"},"message":"Consolidated system observables (#53)","tree":{"sha":"22fbe9e9203703a4edb0eb0e93319c612d2abe3e","url":"https://api.github.com/repos/google/agera/git/trees/22fbe9e9203703a4edb0eb0e93319c612d2abe3e"},"url":"https://api.github.com/repos/google/agera/git/commits/34977ea92427dc456243640baa23bf2cd62a11f8","comment_count":0},"url":"https://api.github.com/repos/google/agera/commits/34977ea92427dc456243640baa23bf2cd62a11f8","html_url":"https://github.com/google/agera/commit/34977ea92427dc456243640baa23bf2cd62a11f8","comments_url":"https://api.github.com/repos/google/agera/commits/34977ea92427dc456243640baa23bf2cd62a11f8/comments","author":{"login":"ernstsson","id":378389,"avatar_url":"https://avatars2.githubusercontent.com/u/378389?v=3","gravatar_id":"","url":"https://api.github.com/users/ernstsson","html_url":"https://github.com/ernstsson","followers_url":"https://api.github.com/users/ernstsson/followers","following_url":"https://api.github.com/users/ernstsson/following{/other_user}","gists_url":"https://api.github.com/users/ernstsson/gists{/gist_id}","starred_url":"https://api.github.com/users/ernstsson/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ernstsson/subscriptions","organizations_url":"https://api.github.com/users/ernstsson/orgs","repos_url":"https://api.github.com/users/ernstsson/repos","events_url":"https://api.github.com/users/ernstsson/events{/privacy}","received_events_url":"https://api.github.com/users/ernstsson/received_events","type":"User","site_admin":false},"committer":{"login":"ernstsson","id":378389,"avatar_url":"https://avatars2.githubusercontent.com/u/378389?v=3","gravatar_id":"","url":"https://api.github.com/users/ernstsson","html_url":"https://github.com/ernstsson","followers_url":"https://api.github.com/users/ernstsson/followers","following_url":"https://api.github.com/users/ernstsson/following{/other_user}","gists_url":"https://api.github.com/users/ernstsson/gists{/gist_id}","starred_url":"https://api.github.com/users/ernstsson/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ernstsson/subscriptions","organizations_url":"https://api.github.com/users/ernstsson/orgs","repos_url":"https://api.github.com/users/ernstsson/repos","events_url":"https://api.github.com/users/ernstsson/events{/privacy}","received_events_url":"https://api.github.com/users/ernstsson/received_events","type":"User","site_admin":false},"parents":[{"sha":"5555880a4997cacc83fd9bbd8be8cd01d8d7cc77","url":"https://api.github.com/repos/google/agera/commits/5555880a4997cacc83fd9bbd8be8cd01d8d7cc77","html_url":"https://github.com/google/agera/commit/5555880a4997cacc83fd9bbd8be8cd01d8d7cc77"}],"stats":{"total":283,"additions":109,"deletions":174},"files":[{"sha":"26f519ad17196d41571da15249f318c447348b57","filename":"agera/src/main/java/com/google/android/agera/BaseObservable.java","status":"modified","additions":86,"deletions":103,"changes":189,"blob_url":"https://github.com/google/agera/blob/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/BaseObservable.java","raw_url":"https://github.com/google/agera/raw/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/BaseObservable.java","contents_url":"https://api.github.com/repos/google/agera/contents/agera/src/main/java/com/google/android/agera/BaseObservable.java?ref=34977ea92427dc456243640baa23bf2cd62a11f8","patch":"@@ -15,10 +15,11 @@\n  */\n package com.google.android.agera;\n \n+import static android.os.SystemClock.elapsedRealtime;\n+import static com.google.android.agera.Preconditions.checkState;\n import static com.google.android.agera.WorkerHandler.MSG_LAST_REMOVED;\n import static com.google.android.agera.WorkerHandler.MSG_UPDATE;\n import static com.google.android.agera.WorkerHandler.workerHandler;\n-import static com.google.android.agera.Preconditions.checkState;\n \n import android.os.Handler;\n import android.os.Looper;\n@@ -38,149 +39,131 @@\n  */\n public abstract class BaseObservable implements Observable {\n   @NonNull\n-  private final Worker worker;\n+  private static final Object[] NO_UPDATABLES_OR_HANDLERS = new Object[0];\n+  @NonNull\n+  private final WorkerHandler handler;\n+  private final int shortestUpdateWindowMillis;\n+\n+  @NonNull\n+  private Object[] updatablesAndHandlers;\n+  private int size;\n+  private long lastUpdateTimestamp;\n \n   protected BaseObservable() {\n+    this(0);\n+  }\n+\n+  BaseObservable(final int shortestUpdateWindowMillis) {\n     checkState(Looper.myLooper() != null, \"Can only be created on a Looper thread\");\n-    worker = new Worker(this);\n+    this.shortestUpdateWindowMillis = shortestUpdateWindowMillis;\n+    this.handler = workerHandler();\n+    this.updatablesAndHandlers = NO_UPDATABLES_OR_HANDLERS;\n+    this.size = 0;\n   }\n \n   @Override\n-  public final void addUpdatable(@NonNull final Updatable updatable) {\n+  public synchronized final void addUpdatable(@NonNull final Updatable updatable) {\n     checkState(Looper.myLooper() != null, \"Can only be added on a Looper thread\");\n-    worker.addUpdatable(updatable);\n+    add(updatable, workerHandler());\n+    if (size == 1) {\n+      if (handler.hasMessages(MSG_LAST_REMOVED, this)) {\n+        handler.removeMessages(MSG_LAST_REMOVED, this);\n+      } else {\n+        handler.obtainMessage(WorkerHandler.MSG_FIRST_ADDED, this).sendToTarget();\n+      }\n+    }\n   }\n \n   @Override\n-  public final void removeUpdatable(@NonNull final Updatable updatable) {\n+  public synchronized final void removeUpdatable(@NonNull final Updatable updatable) {\n     checkState(Looper.myLooper() != null, \"Can only be removed on a Looper thread\");\n-    worker.removeUpdatable(updatable);\n+    remove(updatable);\n+    if (size == 0) {\n+      handler.obtainMessage(MSG_LAST_REMOVED, this).sendToTarget();\n+      handler.removeMessages(MSG_UPDATE, this);\n+    }\n   }\n \n   /**\n    * Notifies all registered {@link Updatable}s.\n    */\n   protected final void dispatchUpdate() {\n-    worker.dispatchUpdate();\n-  }\n-\n-  /**\n-   * Called from the worker looper thread when this {@link Observable} is activated by transitioning\n-   * from having no client {@link Updatable}s to having at least one client {@link Updatable}.\n-   */\n-  protected void observableActivated() {}\n-\n-  /**\n-   * Called from the worker looper thread when this {@link Observable} is deactivated by\n-   * transitioning from having at least one client {@link Updatable} to having no client\n-   * {@link Updatable}s.\n-   */\n-  protected void observableDeactivated() {}\n-\n-  /**\n-   * Worker and synchronization lock behind a {@link BaseObservable}.\n-   */\n-  static final class Worker {\n-    @NonNull\n-    private static final Object[] NO_UPDATABLES_OR_HANDLERS = new Object[0];\n-\n-    @NonNull\n-    private final BaseObservable baseObservable;\n-    @NonNull\n-    private final WorkerHandler handler;\n-\n-    @NonNull\n-    private Object[] updatablesAndHandlers;\n-    private int size;\n-\n-    Worker(@NonNull final BaseObservable baseObservable) {\n-      this.baseObservable = baseObservable;\n-      this.handler = workerHandler();\n-      this.updatablesAndHandlers = NO_UPDATABLES_OR_HANDLERS;\n-      this.size = 0;\n+    if (!handler.hasMessages(MSG_UPDATE, this)) {\n+      handler.obtainMessage(MSG_UPDATE, this).sendToTarget();\n     }\n+  }\n \n-    synchronized void addUpdatable(@NonNull final Updatable updatable) {\n-      add(updatable, workerHandler());\n-      if (size == 1) {\n-        if (handler.hasMessages(MSG_LAST_REMOVED, this)) {\n-          handler.removeMessages(MSG_LAST_REMOVED, this);\n-        } else {\n-          handler.obtainMessage(WorkerHandler.MSG_FIRST_ADDED, this).sendToTarget();\n-        }\n-      }\n-    }\n \n-    synchronized void removeUpdatable(@NonNull final Updatable updatable) {\n-      remove(updatable);\n-      if (size == 0) {\n-        handler.obtainMessage(MSG_LAST_REMOVED, this).sendToTarget();\n+  private void add(@NonNull final Updatable updatable, @NonNull final Handler handler) {\n+    int indexToAdd = -1;\n+    for (int index = 0; index < updatablesAndHandlers.length; index += 2) {\n+      if (updatablesAndHandlers[index] == updatable) {\n+        throw new IllegalStateException(\"Updatable already added, cannot add.\");\n       }\n-    }\n-\n-    void dispatchUpdate() {\n-      if (!handler.hasMessages(MSG_UPDATE, this)) {\n-        handler.obtainMessage(MSG_UPDATE, this).sendToTarget();\n+      if (updatablesAndHandlers[index] == null) {\n+        indexToAdd = index;\n       }\n     }\n-\n-    private void add(@NonNull final Updatable updatable, @NonNull final Handler handler) {\n-      boolean added = false;\n-      for (int index = 0; index < updatablesAndHandlers.length; index += 2) {\n-        if (updatablesAndHandlers[index] == updatable) {\n-          throw new IllegalStateException(\"Updatable already added, cannot add.\");\n-        }\n-        if (updatablesAndHandlers[index] == null && !added) {\n-          updatablesAndHandlers[index] = updatable;\n-          updatablesAndHandlers[index + 1] = handler;\n-          added = true;\n-        }\n-      }\n-      if (!added) {\n-        final int newIndex = updatablesAndHandlers.length;\n-        updatablesAndHandlers = Arrays.copyOf(updatablesAndHandlers,\n-            Math.max(newIndex * 2, newIndex + 2));\n-        updatablesAndHandlers[newIndex] = updatable;\n-        updatablesAndHandlers[newIndex + 1] = handler;\n-      }\n-      size++;\n+    if (indexToAdd == -1) {\n+      indexToAdd = updatablesAndHandlers.length;\n+      updatablesAndHandlers = Arrays.copyOf(updatablesAndHandlers,\n+          indexToAdd < 2 ? 2 : indexToAdd * 2);\n     }\n+    updatablesAndHandlers[indexToAdd] = updatable;\n+    updatablesAndHandlers[indexToAdd + 1] = handler;\n+    size++;\n+  }\n \n-    private void remove(@NonNull final Updatable updatable) {\n-      for (int index = 0; index < updatablesAndHandlers.length; index += 2) {\n-        if (updatablesAndHandlers[index] == updatable) {\n-          ((WorkerHandler) updatablesAndHandlers[index + 1]).removeMessages(\n-              WorkerHandler.MSG_CALL_UPDATABLE, updatable);\n-          updatablesAndHandlers[index] = null;\n-          updatablesAndHandlers[index + 1] = null;\n-          size--;\n-          return;\n-        }\n+  private void remove(@NonNull final Updatable updatable) {\n+    for (int index = 0; index < updatablesAndHandlers.length; index += 2) {\n+      if (updatablesAndHandlers[index] == updatable) {\n+        ((WorkerHandler) updatablesAndHandlers[index + 1]).removeMessages(\n+            WorkerHandler.MSG_CALL_UPDATABLE, updatable);\n+        updatablesAndHandlers[index] = null;\n+        updatablesAndHandlers[index + 1] = null;\n+        size--;\n+        return;\n       }\n-      throw new IllegalStateException(\"Updatable not added, cannot remove.\");\n     }\n+    throw new IllegalStateException(\"Updatable not added, cannot remove.\");\n+  }\n \n-    synchronized void sendUpdate() {\n+  synchronized void sendUpdate() {\n+    handler.removeMessages(WorkerHandler.MSG_UPDATE, this);\n+    final long elapsedRealtimeMillis =\n+        shortestUpdateWindowMillis > 0 ? elapsedRealtime() : 0;\n+    final long timeFromLastUpdate = elapsedRealtimeMillis - lastUpdateTimestamp;\n+    if (timeFromLastUpdate >= shortestUpdateWindowMillis) {\n+      lastUpdateTimestamp = elapsedRealtimeMillis;\n       for (int index = 0; index < updatablesAndHandlers.length; index = index + 2) {\n         final Updatable updatable = (Updatable) updatablesAndHandlers[index];\n         final WorkerHandler handler =\n             (WorkerHandler) updatablesAndHandlers[index + 1];\n         if (updatable != null) {\n           if (handler.getLooper() == Looper.myLooper()) {\n+            handler.removeMessages(WorkerHandler.MSG_CALL_UPDATABLE, updatable);\n             updatable.update();\n           } else if (!handler.hasMessages(WorkerHandler.MSG_CALL_UPDATABLE, updatable)) {\n             handler.obtainMessage(WorkerHandler.MSG_CALL_UPDATABLE, updatable).sendToTarget();\n           }\n         }\n       }\n+    } else {\n+      handler.sendMessageDelayed(handler.obtainMessage(WorkerHandler.MSG_UPDATE, this),\n+          shortestUpdateWindowMillis - timeFromLastUpdate);\n     }\n+  }\n \n-    void callFirstUpdatableAdded() {\n-      baseObservable.observableActivated();\n-    }\n+  /**\n+   * Called from the worker looper thread when this {@link Observable} is activated by transitioning\n+   * from having no client {@link Updatable}s to having at least one client {@link Updatable}.\n+   */\n+  protected void observableActivated() {}\n \n-    void callLastUpdatableRemoved() {\n-      baseObservable.observableDeactivated();\n-    }\n-  }\n+  /**\n+   * Called from the worker looper thread when this {@link Observable} is deactivated by\n+   * transitioning from having at least one client {@link Updatable} to having no client\n+   * {@link Updatable}s.\n+   */\n+  protected void observableDeactivated() {}\n }"},{"sha":"b08a2a7f96b42f37bae2501086257b5fa368fa0b","filename":"agera/src/main/java/com/google/android/agera/CompiledRepository.java","status":"modified","additions":2,"deletions":3,"changes":5,"blob_url":"https://github.com/google/agera/blob/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/CompiledRepository.java","raw_url":"https://github.com/google/agera/raw/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/CompiledRepository.java","contents_url":"https://api.github.com/repos/google/agera/contents/agera/src/main/java/com/google/android/agera/CompiledRepository.java?ref=34977ea92427dc456243640baa23bf2cd62a11f8","patch":"@@ -49,10 +49,9 @@ static Repository compiledRepository(\n       @NonNull final Merger<Object, Object, Boolean> notifyChecker,\n       @RepositoryConfig final int concurrentUpdateConfig,\n       @RepositoryConfig final int deactivationConfig) {\n-    final Observable eventSource = perMillisecondObservable(frequency,\n-        compositeObservable(eventSources.toArray(new Observable[eventSources.size()])));\n     final Object[] directiveArray = directives.toArray();\n-    return new CompiledRepository(initialValue, eventSource,\n+    return new CompiledRepository(initialValue, compositeObservable(frequency,\n+        eventSources.toArray(new Observable[eventSources.size()])),\n         directiveArray, notifyChecker, deactivationConfig, concurrentUpdateConfig);\n   }\n "},{"sha":"7b6218671dc9295f316762b3ec149f418282230c","filename":"agera/src/main/java/com/google/android/agera/Observables.java","status":"modified","additions":18,"deletions":60,"changes":78,"blob_url":"https://github.com/google/agera/blob/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/Observables.java","raw_url":"https://github.com/google/agera/raw/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/Observables.java","contents_url":"https://api.github.com/repos/google/agera/contents/agera/src/main/java/com/google/android/agera/Observables.java?ref=34977ea92427dc456243640baa23bf2cd62a11f8","patch":"@@ -15,11 +15,9 @@\n  */\n package com.google.android.agera;\n \n-import static com.google.android.agera.WorkerHandler.workerHandler;\n import static com.google.android.agera.Preconditions.checkNotNull;\n \n import android.os.Looper;\n-import android.os.SystemClock;\n import android.support.annotation.NonNull;\n import android.support.annotation.Nullable;\n \n@@ -45,17 +43,23 @@\n    */\n   @NonNull\n   public static Observable compositeObservable(@NonNull final Observable... observables) {\n+    return compositeObservable(0, observables);\n+  }\n+\n+  @NonNull\n+  static Observable compositeObservable(final int shortestUpdateWindowMillis,\n+      @NonNull final Observable... observables) {\n     if (observables.length == 0) {\n-      return new CompositeObservable();\n+      return new CompositeObservable(0);\n     }\n \n     if (observables.length == 1) {\n       final Observable singleObservable = observables[0];\n       if (singleObservable instanceof CompositeObservable) {\n-        return new CompositeObservable(\n+        return new CompositeObservable(0,\n             ((CompositeObservable) singleObservable).observables);\n       } else {\n-        return new CompositeObservable(singleObservable);\n+        return new CompositeObservable(0, singleObservable);\n       }\n     }\n \n@@ -73,7 +77,7 @@ public static Observable compositeObservable(@NonNull final Observable... observ\n         }\n       }\n     }\n-    return new CompositeObservable(\n+    return new CompositeObservable(0,\n         flattenedDedupedObservables.toArray(new Observable[flattenedDedupedObservables.size()]));\n   }\n \n@@ -89,22 +93,22 @@ public static Observable conditionalObservable(\n \n   /**\n    * Returns an {@link Observable} that notifies added {@link Updatable}s that the\n-   * {@code observable} has changed, but never more often than every\n+   * {@code observables} has changed, but never more often than every\n    * {@code shortestUpdateWindowMillis}.\n    */\n   @NonNull\n   public static Observable perMillisecondObservable(\n-      final int shortestUpdateWindowMillis, @NonNull final Observable observable) {\n-    return new LowPassFilterObservable(shortestUpdateWindowMillis, observable);\n+      final int shortestUpdateWindowMillis, @NonNull final Observable... observables) {\n+    return compositeObservable(shortestUpdateWindowMillis, observables);\n   }\n \n   /**\n    * Returns an {@link Observable} that notifies added {@link Updatable}s that the\n    * {@code observable} has changed, but never more often than once per {@link Looper} cycle.\n    */\n   @NonNull\n-  public static Observable perLoopObservable(@NonNull final Observable observable) {\n-    return perMillisecondObservable(0, observable);\n+  public static Observable perLoopObservable(@NonNull final Observable... observables) {\n+    return compositeObservable(observables);\n   }\n \n   /**\n@@ -142,7 +146,9 @@ public static UpdateDispatcher updateDispatcher(\n     @NonNull\n     private final Observable[] observables;\n \n-    CompositeObservable(@NonNull final Observable... observables) {\n+    CompositeObservable(final int shortestUpdateWindowMillis,\n+        @NonNull final Observable... observables) {\n+      super(shortestUpdateWindowMillis);\n       this.observables = observables;\n     }\n \n@@ -196,54 +202,6 @@ public void update() {\n     }\n   }\n \n-  static final class LowPassFilterObservable extends BaseObservable implements Updatable {\n-    @NonNull\n-    private final Observable observable;\n-    @NonNull\n-    private final WorkerHandler workerHandler;\n-    private final int shortestUpdateWindowMillis;\n-\n-    private long lastUpdateTimestamp;\n-\n-    LowPassFilterObservable(final int shortestUpdateWindowMillis,\n-        @NonNull final Observable observable) {\n-      this.shortestUpdateWindowMillis = shortestUpdateWindowMillis;\n-      this.observable = checkNotNull(observable);\n-      this.workerHandler = workerHandler();\n-    }\n-\n-    @Override\n-    protected void observableActivated() {\n-      observable.addUpdatable(this);\n-    }\n-\n-    @Override\n-    protected void observableDeactivated() {\n-      observable.removeUpdatable(this);\n-      workerHandler.removeMessages(WorkerHandler.MSG_CALL_LOW_PASS_UPDATE, this);\n-    }\n-\n-    @Override\n-    public void update() {\n-      workerHandler.sendMessageDelayed(\n-          workerHandler.obtainMessage(WorkerHandler.MSG_CALL_LOW_PASS_UPDATE, this), (long) 0);\n-    }\n-\n-    void lowPassUpdate() {\n-      workerHandler.removeMessages(WorkerHandler.MSG_CALL_LOW_PASS_UPDATE, this);\n-      final long elapsedRealtimeMillis = SystemClock.elapsedRealtime();\n-      final long timeFromLastUpdate = elapsedRealtimeMillis - lastUpdateTimestamp;\n-      if (timeFromLastUpdate >= shortestUpdateWindowMillis) {\n-        lastUpdateTimestamp = elapsedRealtimeMillis;\n-        dispatchUpdate();\n-      } else {\n-        workerHandler.sendMessageDelayed(\n-            workerHandler.obtainMessage(WorkerHandler.MSG_CALL_LOW_PASS_UPDATE, this),\n-            shortestUpdateWindowMillis - timeFromLastUpdate);\n-      }\n-    }\n-  }\n-\n   private static final class AsyncUpdateDispatcher extends BaseObservable\n       implements UpdateDispatcher {\n "},{"sha":"fec08149586b2073f4721b35e840820daf48b714","filename":"agera/src/main/java/com/google/android/agera/WorkerHandler.java","status":"modified","additions":3,"deletions":7,"changes":10,"blob_url":"https://github.com/google/agera/blob/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/WorkerHandler.java","raw_url":"https://github.com/google/agera/raw/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/main/java/com/google/android/agera/WorkerHandler.java","contents_url":"https://api.github.com/repos/google/agera/contents/agera/src/main/java/com/google/android/agera/WorkerHandler.java?ref=34977ea92427dc456243640baa23bf2cd62a11f8","patch":"@@ -16,7 +16,6 @@\n   static final int MSG_CALL_UPDATABLE = 3;\n   static final int MSG_CALL_MAYBE_START_FLOW = 4;\n   static final int MSG_CALL_ACKNOWLEDGE_CANCEL = 5;\n-  static final int MSG_CALL_LOW_PASS_UPDATE = 6;\n   private static final ThreadLocal<WeakReference<WorkerHandler>> handlers = new ThreadLocal<>();\n \n   @NonNull\n@@ -36,13 +35,13 @@ private WorkerHandler() {}\n   public void handleMessage(final Message message) {\n     switch (message.what) {\n       case MSG_UPDATE:\n-        ((BaseObservable.Worker) message.obj).sendUpdate();\n+        ((BaseObservable) message.obj).sendUpdate();\n         break;\n       case MSG_FIRST_ADDED:\n-        ((BaseObservable.Worker) message.obj).callFirstUpdatableAdded();\n+        ((BaseObservable) message.obj).observableActivated();\n         break;\n       case MSG_LAST_REMOVED:\n-        ((BaseObservable.Worker) message.obj).callLastUpdatableRemoved();\n+        ((BaseObservable) message.obj).observableDeactivated();\n         break;\n       case MSG_CALL_UPDATABLE:\n         ((Updatable) message.obj).update();\n@@ -53,9 +52,6 @@ public void handleMessage(final Message message) {\n       case MSG_CALL_ACKNOWLEDGE_CANCEL:\n         ((CompiledRepository) message.obj).acknowledgeCancel();\n         break;\n-      case MSG_CALL_LOW_PASS_UPDATE:\n-        ((Observables.LowPassFilterObservable) message.obj).lowPassUpdate();\n-        break;\n       default:\n     }\n   }"},{"sha":"768a53d38df1914e2e7a5a355ceffed44bc306a3","filename":"agera/src/test/java/com/google/android/agera/RepositoriesTest.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/google/agera/blob/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/test/java/com/google/android/agera/RepositoriesTest.java","raw_url":"https://github.com/google/agera/raw/34977ea92427dc456243640baa23bf2cd62a11f8/agera/src/test/java/com/google/android/agera/RepositoriesTest.java","contents_url":"https://api.github.com/repos/google/agera/contents/agera/src/test/java/com/google/android/agera/RepositoriesTest.java?ref=34977ea92427dc456243640baa23bf2cd62a11f8","patch":"@@ -29,7 +29,6 @@\n import static java.util.Arrays.asList;\n import static java.util.Collections.singletonList;\n import static org.hamcrest.MatcherAssert.assertThat;\n-import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyZeroInteractions;"}]}